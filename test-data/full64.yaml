# Copyright (c) Prevail Verifier contributors.
# SPDX-License-Identifier: MIT
---
test-case: compute negative interval without wrap

pre: ["r1.type=number", "r1.svalue=[1, 3]", "r1.uvalue=[1, 3]"]

code:
  <start>: |
    r1 += -4 ; this should remain a signed interval

post:
  - r1.type=number
  - r1.svalue=[-3, -1]
  - r1.uvalue=[18446744073709551613, 18446744073709551615]
---
test-case: compute negative interval using overflow

pre: ["r1.type=number", "r1.svalue=[9223372036854775805, 9223372036854775807]", "r1.uvalue=[9223372036854775805, 9223372036854775807]",
      "r2.type=number", "r2.svalue=9223372036854775807", "r2.uvalue=9223372036854775807"]

code:
  <start>: |
    r1 += r2 ; [INT64_MAX+INT64_MAX-2, INT64_MAX+INT64_MAX]

post:
  - r1.type=number
  - r1.svalue=[-4, -2]
  - r1.uvalue=[18446744073709551612, 18446744073709551614]
  - r2.type=number
  - r2.svalue=9223372036854775807
  - r2.uvalue=9223372036854775807
  - r1.uvalue-r2.svalue<=9223372036854775807
  - r2.svalue-r1.uvalue<=-9223372036854775805
---
test-case: compute an interval that can only be represented using an unsigned interval

pre: ["r1.type=number", "r1.svalue=[9223372036854775805, 9223372036854775807]", "r1.uvalue=[9223372036854775805, 9223372036854775807]"]

code:
  <start>: |
    r1 += 2 ; result is [INT64_MAX, INT64_MAX+2]

post:
  - r1.type=number
  - r1.uvalue=[9223372036854775807, 9223372036854775809]
---
test-case: compute negative interval from unsigned interval with overflow

pre: ["r1.type=number", "r1.svalue=[9223372036854775805, 9223372036854775807]", "r1.uvalue=[9223372036854775805, 9223372036854775807]"]

code:
  <start>: |
    r1 += 2 ; result is [INT64_MAX, INT64_MAX+2] => unsigned interval
    r1 += 1 ; result is [INT64_MAX+1, INT64_MAX+3] => [INT64_MIN, INT64_MIN+2]

post:
  - r1.type=number
  - r1.svalue=[-9223372036854775808, -9223372036854775806]
  - r1.uvalue=[9223372036854775808, 9223372036854775810]
---
test-case: cast signed interval crossing 0 to unsigned

pre: ["r0.type=number", "r0.svalue=0", "r0.uvalue=0",
      "r1.type=number", "r1.svalue=[-1, 1]"]

code:
  <start>: |
    if r1 < 2 goto <label_0> ; unsigned comparison so should go to TOP and be both true and false
    r0 = 1
  <label_0>: |
    exit

post:
  - r0.type=number
  - r0.svalue=[0, 1]
  - r0.uvalue=[0, 1]
  - r0.svalue=r0.uvalue
  - r1.type=number
  - r1.svalue=[-1, 1]
  - r0.svalue-r1.uvalue<=0
  - r0.uvalue-r1.uvalue<=0
  - r1.uvalue-r0.svalue<=18446744073709551614
  - r1.uvalue-r0.uvalue<=18446744073709551614
  - r1.uvalue=[0, 18446744073709551615]
---
test-case: cast unsigned interval crossing ((uint64_t)INT64_MAX) to signed

pre: ["r0.type=number", "r0.svalue=0", "r0.uvalue=0",
      "r1.type=number", "r1.svalue=[9223372036854775805, 9223372036854775807]", "r1.uvalue=[9223372036854775805, 9223372036854775807]"]

code:
  <start>: |
    r1 += 2 ; result is [INT64_MAX, INT64_MAX+2] as an unsigned interval
    if r1 s> 0 goto <label_0> ; signed comparison so should go to TOP and be both true and false
    r0 = 1
  <label_0>: |
    exit

post:
  - r0.type=number
  - r0.svalue=[0, 1]
  - r0.uvalue=[0, 1]
  - r0.svalue=r0.uvalue
  - r1.type=number
  - r1.uvalue=[9223372036854775807, 9223372036854775809]
---
test-case: not equal 0

pre: ["r0.type=number"]

code:
  <start>: |
    if r0 != 0 goto <label_0>
    r0 = 17
  <label_0>: |
    exit

post:
  - r0.type=number
  - r0.uvalue=[1, 18446744073709551615]
---
test-case: create unsigned infinite interval

pre: ["r0.type=number"]

code:
  <start>: |
    if r0 > 0 goto <label_0>
    r0 = 17
  <label_0>: |
    exit

post:
  - r0.type=number
  - r0.uvalue=[1, 18446744073709551615]
---
test-case: create signed infinite interval

pre: ["r0.type=number"]

code:
  <start>: |
    if r0 s> 0 goto <label_0>
    r0 = 1
  <label_0>: |
    exit

post:
  - r0.type=number
  - r0.svalue=[1, +oo]
---
test-case: addition with signed infinite interval

pre: ["r0.type=number"]

code:
  <start>: |
    if r0 s> 0 goto <label_0>
    r0 = 1
  <label_0>: |
    r0 += 2 ; [1, +oo] + 2 => TOP
    exit

post:
  - r0.type=number
