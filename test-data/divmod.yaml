# Copyright (c) Prevail Verifier contributors.
# SPDX-License-Identifier: MIT
---
test-case: non-zero divided by zero immediate

pre: ["r1.type=number", "r1.value=6"]

code:
  <start>: |
    r1 /= 0

post: []

messages:
  - "0: Code is unreachable after 0"
---
test-case: zero divided by zero immediate

pre: ["r1.type=number", "r1.value=0"]

code:
  <start>: |
    r1 /= 0

post: []

messages:
  - "0: Code is unreachable after 0"
---
test-case: non-zero divided by zero register

pre: ["r1.type=number", "r1.value=6", "r2.type=number", "r2.value=0"]

code:
  <start>: |
    r1 /= r2

post: []

messages:
  - "0: Code is unreachable after 0"
---
test-case: zero divided by zero register

pre: ["r1.type=number", "r1.value=0", "r2.type=number", "r2.value=0"]

code:
  <start>: |
    r1 /= r2

post: []

messages:
  - "0: Code is unreachable after 0"
---
test-case: non-zero divided by possibly zero register

pre: ["r1.type=number", "r1.value=6", "r2.type=number", "r2.value=[-5, 5]"]

code:
  <start>: |
    r1 /= r2  ; this could divide by 0

post:
  - r1.type=number
  - r1.value=[-6, 6]
  - r2.type=number
  - r2.value=[-5, 5]
---
test-case: zero divided by possibly zero register

pre: ["r1.type=number", "r1.value=0", "r2.type=number", "r2.value=[-5, 5]"]

code:
  <start>: |
    r1 /= r2 ; this could divide by 0 but ok to set to 0

post:
  - r1.type=number
  - r1.value=0
  - r2.type=number
  - r2.value=[-5, 5]
---
test-case: non-zero divided by possibly zero register 2

pre: ["r1.type=number", "r1.value=6", "r2.type=number", "r2.value=[-5, 0]"]

code:
  <start>: |
    r1 /= r2  ; this could divide by 0

post:
  - r1.type=number
  - r1.value=[-6, -1]
  - r2.type=number
  - r2.value=[-5, 0]
---
test-case: zero divided by possibly zero register 2

pre: ["r1.type=number", "r1.value=0", "r2.type=number", "r2.value=[-5, 0]"]

code:
  <start>: |
    r1 /= r2 ; this could divide by 0 but ok to set to 0

post:
  - r1.type=number
  - r1.value=0
  - r2.type=number
  - r2.value=[-5, 0]
---
test-case: non-zero divided by undefined value register

pre: ["r1.type=number", "r1.value=6", "r2.type=number"]

code:
  <start>: |
    r1 /= r2  ; this could divide by 0

post:
  - r1.type=number
  - r2.type=number
---
test-case: zero divided by undefined value register

pre: ["r1.type=number", "r1.value=0", "r2.type=number"]

code:
  <start>: |
    r1 /= r2  ; this could divide by 0

post:
  - r1.type=number
  - r1.value=0
  - r2.type=number
---
test-case: non-zero modulo zero immediate

pre: ["r1.type=number", "r1.value=6"]

code:
  <start>: |
    r1 %= 0

post: []

messages:
  - "0: Code is unreachable after 0"
---
test-case: zero modulo zero immediate

pre: ["r1.type=number", "r1.value=0"]

code:
  <start>: |
    r1 %= 0

post: []

messages:
  - "0: Code is unreachable after 0"
---
test-case: non-zero modulo zero register

pre: ["r1.type=number", "r1.value=6", "r2.type=number", "r2.value=0"]

code:
  <start>: |
    r1 %= r2

post: []

messages:
  - "0: Code is unreachable after 0"
---
test-case: zero modulo zero register

pre: ["r1.type=number", "r1.value=0", "r2.type=number", "r2.value=0"]

code:
  <start>: |
    r1 %= r2

post: []

messages:
  - "0: Code is unreachable after 0"
---
test-case: non-zero modulo possibly zero register

pre: ["r1.type=number", "r1.value=6", "r2.type=number", "r2.value=[-5, 5]"]

code:
  <start>: |
    r1 %= r2 ; this could do modulo 0 so could set r1 = r2

post:
  - r1.type=number
  - r1.value=[0, 4]
  - r2.type=number
  - r2.value=[-5, 5]
---
test-case: zero modulo possibly zero register

pre: ["r1.type=number", "r1.value=0", "r2.type=number", "r2.value=[-5, 5]"]

code:
  <start>: |
    r1 %= r2 ; this could do modulo 0 so could set r1 = r2

post:
  - r1.type=number
  - r1.value=[0, 4]
  - r2.type=number
  - r2.value=[-5, 5]
---
test-case: non-zero modulo possibly zero register 2

pre: ["r1.type=number", "r1.value=6", "r2.type=number", "r2.value=[-5, 0]"]

code:
  <start>: |
    r1 %= r2 ; this could do modulo 0 so could set r1 = r2

post:
  - r1.type=number
  - r1.value=[0, 4]
  - r2.type=number
  - r2.value=[-5, 0]
---
test-case: zero modulo possibly zero register 2

pre: ["r1.type=number", "r1.value=0", "r2.type=number", "r2.value=[-5, 0]"]

code:
  <start>: |
    r1 %= r2 ; this could do modulo 0 so could set r1 = r2

post:
  - r1.type=number
  - r1.value=[0, 4]
  - r2.type=number
  - r2.value=[-5, 0]
---
test-case: non-zero modulo undefined value register

pre: ["r1.type=number", "r1.value=6", "r2.type=number"]

code:
  <start>: |
    r1 %= r2  ; this could be modulo 0

post:
  - r1.type=number
  - r2.type=number
---
test-case: zero modulo undefined value register

pre: ["r1.type=number", "r1.value=0", "r2.type=number"]

code:
  <start>: |
    r1 %= r2  ; this could be modulo 0

post:
  - r1.type=number
  - r2.type=number
---
test-case: positive modulo positive

pre: ["r1.type=number", "r1.value=13"]

code:
  <start>: |
    r1 %= 3

post:
  - r1.type=number
  - r1.value=1
---
test-case: negative modulo positive

pre: ["r1.type=number", "r1.value=-13"]

code:
  <start>: |
    r1 %= 3

post:
  - r1.type=number
  - r1.value=-1
---
test-case: positive modulo negative

pre: ["r1.type=number", "r1.value=13"]

code:
  <start>: |
    r1 %= -3

post:
  - r1.type=number
  - r1.value=1
---
test-case: negative modulo negative

pre: ["r1.type=number", "r1.value=-13"]

code:
  <start>: |
    r1 %= -3

post:
  - r1.type=number
  - r1.value=-1
---
test-case: smaller modulo larger

pre: ["r1.type=number", "r1.value=6", "r2.type=number", "r2.value=[7, 10]"]

code:
  <start>: |
    r1 %= r2

post:
  - r1.type=number
  - r1.value=[0, 9]
  - r2.type=number
  - r2.value=[7, 10]
